Today we’re talking about Apache Calcite.

Imagine you have data spread across a CSV file, a MongoDB instance, and Elasticsearch. Normally, you’d have to learn three different query languages to talk to them. Calcite is a framework that lets you use one single SQL query to reach all these sources.

Calcite does not store data. It is like a 'brain'. It sits between your application and your data. It understands SQL and finds the best way to get your information.


You send a SQL query. Calcite parses it and creates an Execution Plan. It has an Optimizer that chooses the fastest path to find the data.

We use Calcite for Data Federation. This means joining data from different places. Big projects like Apache Flink and Hive use Calcite as their SQL engine because it is very powerful and flexible.


While showing my code, I need to focus on these points:

The Schema: I used a ReflectiveSchema. This tells Calcite: 'Look at my Java list and treat it like a SQL table.'

The Model: I have a model.json file. It connects the MEMORY schema to my Java objects and the FILES schema to my CSV folder.

The Query: Look at this JOIN: Calcite joins a Java List with a CSV file perfectly.

But, it is not for everything. Don't use Calcite if you need ultra-fast results (like milliseconds), because the 'planning' takes some time.

Also, it can be hard to learn at first. 

The trade-off is: you get total flexibility, but you need to manage the configuration and the small overhead in performance.

In short: Apache Calcite gives SQL superpowers to any system. It lets you focus on the data, not on the connection.